# .github/workflows/deploy-to-aca.yml

name: Deploy Cookbot to Azure Container Apps CI/CD

on:
  push:
    branches:
      - master # Dispara el flujo cuando se haga un push a la rama 'master'

env:
  # Variables de entorno para el flujo de trabajo
  # Estos valores se obtendrán de las 'Environment variables' que configuraste
  # en la interfaz de GitHub (Settings > Secrets and variables > Actions > Environment variables)
  AZURE_RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}
  AZURE_LOCATION: ${{ vars.AZURE_LOCATION }}
  AZURE_ACA_ENVIRONMENT: ${{ vars.AZURE_ACA_ENVIRONMENT }}
  AZURE_ACA_APP_NAME: ${{ vars.AZURE_ACA_APP_NAME }}
  AZURE_ACR_NAME: ${{ vars.AZURE_ACR_NAME }}
  AZURE_PG_SERVER_HOST: ${{ vars.AZURE_PG_SERVER_HOST }}
  AZURE_PG_DB_NAME: ${{ vars.AZURE_PG_DB_NAME }}
  AZURE_PG_ADMIN_USER: ${{ vars.AZURE_PG_ADMIN_USER }}
  AZURE_PG_ADMIN_PASSWORD_ENV: ${{ secrets.AZURE_PG_ADMIN_PASSWORD }} # Temporal para el runner

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest # Ejecuta el trabajo en un runner de Ubuntu
    environment: DEV # NOMBRE DEL ENTORNO DE GITHUB

    steps:
      - name: Checkout Repository # Paso 1: Obtener el código fuente de tu repositorio
        uses: actions/checkout@v4

      - name: Log in to Azure # Paso 2: Autenticarse en Azure usando el Service Principal
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }} # Usa el secreto de GitHub

      - name: Log in to Azure Container Registry (ACR) # Paso 3: Autenticarse en ACR
        uses: azure/docker-login@v1
        with:
          login-server: ${{ env.AZURE_ACR_NAME }}.azurecr.io
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Debug ACR_NAME before build
        run: |
          echo "Valor de AZURE_ACR_NAME en este paso: '${{ env.AZURE_ACR_NAME }}'"
          echo "Valor de AZURE_ACA_APP_NAME en este paso: '${{ env.AZURE_ACA_APP_NAME }}'"
          echo "Valor de github.sha en este paso: '${{ github.sha }}'"
          FULL_IMAGE_TAG="${{ env.AZURE_ACR_NAME }}.azurecr.io/${{ env.AZURE_ACA_APP_NAME }}:${{ github.sha }}"
          echo "Etiqueta completa construida: '$FULL_IMAGE_TAG'"

      - name: Build and push Docker image # Paso 4: Construir y subir la imagen Docker
        run: |
          FULL_IMAGE_TAG="${{ env.AZURE_ACR_NAME }}.azurecr.io/${{ env.AZURE_ACA_APP_NAME }}:${{ github.sha }}"
          echo "Ejecutando docker build con tag: $FULL_IMAGE_TAG"
          docker build . --file Dockerfile --tag "$FULL_IMAGE_TAG"
          docker push "$FULL_IMAGE_TAG"

      - name: Ensure Azure Database for PostgreSQL - Flexible Server exists
        run: |
          echo "Verificando/Creando Azure Database for PostgreSQL - Flexible Server: ${{ env.AZURE_PG_SERVER_HOST }}..."
          PG_SHORT_NAME=$(echo "${{ env.AZURE_PG_SERVER_HOST }}" | cut -d'.' -f1)

          az postgres flexible-server show --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" --name "$PG_SHORT_NAME" > /dev/null 2>&1
          if [ $? -ne 0 ]; then
              echo "PostgreSQL Server '$PG_SHORT_NAME' no existe. Creándolo..."
              az postgres flexible-server create \
                  --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
                  --name "$PG_SHORT_NAME" \
                  --location "${{ env.AZURE_LOCATION }}" \
                  --version 16 \
                  --admin-user "${{ env.AZURE_PG_ADMIN_USER }}" \
                  --admin-password "${{ env.AZURE_PG_ADMIN_PASSWORD_ENV }}" \
                  --sku-name Standard_B1ms \
                  --storage-size 32 \
                  --tier Burstable \
                  --public-access All || { echo "Error al crear PostgreSQL Server. Saliendo."; exit 1; }
              echo "PostgreSQL Server '$PG_SHORT_NAME' creado."
          else
              echo "PostgreSQL Server '$PG_SHORT_NAME' ya existe. Continuando."
          fi

      - name: Configure PostgreSQL Firewall Rule # Opcional: configurar una regla de firewall genérica
        run: |
          echo "Reglas de firewall para PostgreSQL: configuradas manualmente o no necesarias si la app está en la misma VNet."

      - name: Ensure Container App Environment exists
        run: |
          echo "Verificando/Creando el entorno de Azure Container Apps: ${{ env.AZURE_ACA_ENVIRONMENT }} en ${{ env.AZURE_RESOURCE_GROUP }}..."
          az containerapp env show --name "${{ env.AZURE_ACA_ENVIRONMENT }}" --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" > /dev/null 2>&1
          if [ $? -ne 0 ]; then
              echo "El entorno '${{ env.AZURE_ACA_ENVIRONMENT }}' no existe. Creándolo..."
              az containerapp env create \
                  --name "${{ env.AZURE_ACA_ENVIRONMENT }}" \
                  --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
                  --location "${{ env.AZURE_LOCATION }}" || { echo "Error al crear el entorno de Container Apps. Saliendo."; exit 1; }
              echo "Entorno de Container Apps '${{ env.AZURE_ACA_ENVIRONMENT }}' creado."
          else
              echo "El entorno '${{ env.AZURE_ACA_ENVIRONMENT }}' ya existe. Continuando."
          fi

      - name: Deploy to Azure Container Apps # Paso 6: Desplegar la nueva imagen en ACA
        uses: azure/container-apps-deploy-action@v1
        with:
          # ELIMINADO: appSourcePath: .  <-- Esto evita que la acción intente construir de nuevo.
          image: ${{ env.AZURE_ACR_NAME }}.azurecr.io/${{ env.AZURE_ACA_APP_NAME }}:${{ github.sha }}
          resourceGroup: ${{ env.AZURE_RESOURCE_GROUP }}
          containerAppName: ${{ env.AZURE_ACA_APP_NAME }}
          environment: ${{ env.AZURE_ACA_ENVIRONMENT }}
          targetPort: 8080
          ingress: external
          acrName: ${{ env.AZURE_ACR_NAME }} # Nombre corto del ACR
          acrUsername: ${{ secrets.ACR_USERNAME }} # Nombre de usuario del ACR
          acrPassword: ${{ secrets.ACR_PASSWORD }} # Contraseña del ACR
          envVars: |
            DATABASE_URL=postgresql://${{ env.AZURE_PG_ADMIN_USER }}:${{ secrets.AZURE_PG_ADMIN_PASSWORD }}@${{ env.AZURE_PG_SERVER_HOST }}:5432/${{ env.AZURE_PG_DB_NAME }}?sslmode=require&schema=public
            GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY_AZURE }}
            OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY_AZURE }}
            NODE_ENV=production
            PORT=8080

      - name: Run Prisma Migrations and Seed on Container App # Paso 7: Ejecutar migraciones y seeding
        if: success()
        run: |
          echo "Aplicando migraciones de Prisma y ejecutando el script de seeding en la Container App..."
          echo "Esperando 60 segundos para que la revisión de la Container App se propague..."
          sleep 60

          REVISION_NAME=$(az containerapp show --name "${{ env.AZURE_ACA_APP_NAME }}" --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" --query "properties.latestReadyRevisionName" -o tsv)

          if [ -z "$REVISION_NAME" ]; then
              echo "Error: No se pudo obtener el nombre de la revisión activa. Las migraciones y el seeding no se aplicarán."
              exit 1
          else
              echo "Ejecutando npx prisma migrate deploy en la revisión: $REVISION_NAME"
              az containerapp exec --name "${{ env.AZURE_ACA_APP_NAME }}" --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" --command "npx prisma migrate deploy" --revision "$REVISION_NAME" || { echo "Error al aplicar migraciones. Saliendo."; exit 1; }
              echo "Migraciones de Prisma aplicadas."

              echo "Ejecutando npx prisma db seed en la revisión: $REVISION_NAME"
              az containerapp exec --name "${{ env.AZURE_ACA_APP_NAME }}" --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" --command "npx prisma db seed" --revision "$REVISION_NAME" || { echo "Error al ejecutar el script de seeding. Saliendo."; exit 1; }
              echo "Script de seeding de Prisma ejecutado."
          fi
